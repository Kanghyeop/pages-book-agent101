---
title: "LangChain과 LangGraph 이해하기"
nav_order: 3
parent: Part 4
---


유사한 기술 사례를 하나 더 보겠습니다.

간호사 번표는 입력과 출력이 명확한 단일 작업이었습니다. 파일 넣으면 결과가 나오는 구조.

하지만 처음 등장했던 근조화환처럼 여러 단계를 거쳐야 하는 경우도 있습니다. 전화 받고, 결제 확인하고, 발주하고, 배송 추적하고... 각 단계마다 다른 작업을 해야 하고, 조건에 따라 다른 경로로 가야 합니다.

이런 복잡한 흐름을 만들 때 쓰는 도구가 LangChain과 LangGraph입니다. 이름이 비슷하지만 역할이 다릅니다. (반드시 LangChain과 LangGraph를 쓸 필요는 없습니다. 다양한 프레임워크 중 선택을 하면 됩니다. 다만 가장 기초적인 프레임워크를 통해 설명합니다.)

---

## 핵심 개념 미리보기

이 글에서 다룰 핵심 개념입니다:

- LangChain: Chain, Prompt Template, Memory
- LangGraph: State, Node, Edge, Graph

LangChain은 직선적인 흐름, LangGraph는 복잡한 분기와 반복을 다룹니다.

---

## LangChain: LLM 애플리케이션의 기본 도구

LangChain은 LLM으로 애플리케이션을 만들 때 쓰는 기본 프레임워크입니다. 프롬프트 관리, 대화 기록 저장, 외부 도구 연결 같은 공통 기능을 미리 만들어둔 도구 상자입니다.

### 핵심 개념 3가지

![LangChain 핵심 개념](assets/langchain-concepts.svg)

1. Chain (체인): 여러 단계를 순서대로 연결합니다. "요약해줘" 요청이 들어오면 프롬프트 작성 → LLM 호출 → 결과 정리가 한 번에 실행됩니다.

2. Prompt Template (프롬프트 템플릿): 프롬프트 틀을 만들어두고 변수만 바꿉니다.
```
템플릿: "다음 글을 {style} 스타일로 요약해줘: {text}"
사용: style="3줄", text="긴 기사..."
```

3. Memory (메모리): 대화 기록을 저장합니다. "서울 날씨 알려줘" → "내일은?" 이런 맥락을 이해합니다.

### LangChain의 한계

간단한 애플리케이션(문서 요약, Q&A, 번역)은 LangChain만으로 충분합니다. 하지만 복잡한 분기나 반복이 필요하면 한계가 생깁니다.

![LangChain의 한계](assets/langchain-limit.svg)

---

## LangGraph: 복잡한 워크플로우를 위한 도구

LangGraph는 LangChain 팀이 만든 그래프 기반 워크플로우 도구입니다. 복잡한 분기와 반복이 필요할 때 씁니다.

| 구분 | LangChain | LangGraph |
|------|-----------|-----------|
| 구조 | 순차적 체인 | 그래프 (노드와 엣지) |
| 분기 | 제한적 | 자유로움 |
| 반복 | 어려움 | 쉬움 |
| 사용 시점 | 단순한 파이프라인 | 복잡한 워크플로우 |

### 핵심 개념 4가지

![LangGraph 핵심 개념](assets/langgraph-concepts.svg)

1. State (상태): 티켓 하나가 가지고 다니는 정보 꾸러미입니다. "지금 어디까지 왔나?"
```
주문자: 홍길동
배송지: 서울시 강남구
결제 상태: 완료
현재 단계: 발주 완료
```

2. Node (노드): 실제 작업을 수행하는 곳입니다. "여기서 뭘 하나?"
   - 전화 주문접수 노드: 통화 내용 → 주문 정보 추출
   - 결제 확인 노드: PG사 API 호출 → 결제 상태 확인
   - 발주 노드: 외주 ERP에 주문 등록

3. Edge (엣지): 노드와 노드를 연결하는 화살표입니다. "다음엔 어디로?"
   - 고정 엣지: "결제 확인 완료 → 무조건 발주로"
   - 조건부 엣지: "배송 완료면 → 알림 발송, 배송중이면 → 대기"

4. Graph (그래프): 노드들과 엣지들을 연결한 전체 워크플로우입니다.

---

## 근조화환 사례로 이해하기

![근조화환 워크플로우](assets/langgraph-workflow.svg)

실제 흐름:
1. 전화 주문 (ElevenLabs 음성 AI) → State 생성
2. 문자 발송 (결제 링크) → State: "결제 대기"
3. PG Webhook 수신 → State: "결제 완료" → 발주 노드로 이동
4. BrowserUse로 ERP 발주 → State: ERP 주문번호 저장
5. ERP 폴링 → 배송중이면 대기, 완료면 다음 단계
6. 완료 알림 발송 → State: "완료"

---

## 왜 LangGraph를 쓰나요?

1. 흐름이 명확해집니다: if-else 대신 그래프로 한눈에
2. 독립적 관리: "발주 노드만 수정" → 다른 노드 건드릴 필요 없음
3. 예외 처리가 쉬움: 어느 단계에서든 "예외 처리" 노드로 분기
4. 재실행이 쉬움: "결제 대기" 상태에서 멈춰있다가 웹훅 오면 그 지점부터 재개

---

## 24시간 상시 운영

```
while True:
    - DB에서 처리 대기 중인 티켓 조회
    - 각 티켓의 State를 Graph에 태움
    - Graph가 갈 수 있는 데까지 진행
    - State를 DB에 저장
    - 1분 대기 후 반복
```

핵심: 사람은 예외 상황만 처리합니다. 대부분의 티켓은 자동으로 완료까지 처리되며 닫힙니다.

---

## 결론

간단한 단일 흐름은 LangChain, 복잡한 분기 처리는 LangGraph. 코드는 나중에 보고 일단 개념만 이해했으면 됐습니다.

---
<!-- LLM Context Anchor -->
**핵심 요약**: LangChain = LLM앱 기본 프레임워크(Chain, Prompt Template, Memory). 순차적 흐름에 적합. LangGraph = 그래프 기반 워크플로우(State, Node, Edge, Graph). 복잡한 분기/반복에 적합. State=티켓이 가지고 다니는 정보 꾸러미, Node=실제 작업 수행, Edge=다음 단계 연결(고정/조건부). 근조화환 사례: 전화주문→문자→결제→발주→배송추적→완료알림.

**키워드**: `LangChain` `LangGraph` `Chain` `PromptTemplate` `Memory` `State` `Node` `Edge`
