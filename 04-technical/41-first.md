---
title: "41. [v1] 시스템으로 바꾸는 첫 경험"
nav_order: 1
parent: Part 4
---


# [v1] 시스템으로 바꾸는 첫 경험: 간호사 번표

Part 3에서 에이전트의 정의와 다양한 시스템 사례들을 살펴보았습니다. 이제 하나의 업무를 시스템으로 만드는 과정에 대해 구체적인 케이스로 분석해보겠습니다. 간호사 Y씨가 직접 겪었던 '간호사 번표 짜기' 라는 사례를 보겠습니다.

---

## Y씨가 매달 겪는 귀찮은 업무

병동마다 다르지만, 번표는 보통 돌아가면서 짭니다. 이번 달은 Y씨 차례입니다. 

한번 정해지면 변수 제외하고는 바뀌지 않기 때문에, 한번 짤 때 제대로 짜야 합니다. 문제는 이걸 근무 시간에 할 수 없다는 겁니다. 퇴근 후, 쉬는 날, 개인 시간을 이틀 정도 써야 한 달치가 완성됩니다.

왜 이렇게 오래 걸릴까요? 복잡한 경우의 수와 조합 문제를 직접 손으로 풀어야 합니다.

<img width="1893" height="897" alt="image" src="https://github.com/user-attachments/assets/41149fc9-bd6e-44be-9b68-446dd13798a8" />


(세부적인 규칙을 이해할 필요는 없습니다. 그저 20개 이상의 조건들이 복잡하게 얽힌 문제라는 점만을 이야기 합니다.) 

> 매일 낮(D), 저녁(E), 밤(N) 근무에 각각 10명씩 배치해야 합니다. 밤 근무 다음날 낮이나 저녁 근무는 안 됩니다. 밤 근무는 최대 3일 연속까지, 그 후엔 이틀을 쉬어야 합니다. 특정 간호사는 개인 사정으로 밤 근무가 아예 안 됩니다. 연속 근무는 6일까지만. 한 달 총 근무일수는 18~22일 사이로 맞춰야 공정합니다. 여기에 휴가 신청, 특정 날짜 근무 불가 같은 요청사항까지 들어옵니다. 한 명을 배치하면 다른 사람 일정이 밀립니다. 그걸 맞추면 또 다른 사람이 안 맞습니다. 앞부분은 괜찮은데 뒤로 갈수록 넣을 사람이 없어집니다. 결국 앞에서부터 다시.

---

## 시스템으로 바라보기

Y씨의 문제를 시스템 관점에서 보면 단순해집니다.

### 다이어그램 ① - 블랙박스

가장 단순하게 보면, 번표 짜기는 이런 시스템입니다:

![다이어그램 ① - 블랙박스](/pages-book-agent101/assets/41-diagram-1-blackbox.svg)

- 입력 1: 지난달 번표 (지난달에 누가 언제 어떤 근무를 했는지)
- 입력 2: 원티드 = 이번 달 요청사항 (특정 날짜 휴가 신청, 근무 불가 등)
- 출력: 다음달 번표

규칙(밤 근무 다음날 낮 근무 금지, 연속 근무 6일 제한 등)은 매번 바뀌지 않습니다. 시스템 내부에 고정되어 있습니다.

이렇게 보면 명확합니다: 두 가지 변수만 넣으면 다음달 번표가 나오는 시스템을 만들면 됩니다.

---

## 사람은 어렵고, 컴퓨터는 쉬운 문제

Y씨가 힘들어하는 이유는 "규칙이 많아서"가 아닙니다. 규칙이 많은 게 문제가 아니라, 규칙들이 서로 충돌하기 때문입니다.

- "김 간호사를 밤 근무에 넣으면 다음 이틀을 쉬어야 하는데"
- "그럼 그 이틀에 다른 사람을 넣어야 하는데"
- "근데 다른 사람들은 이미 다른 날에 배치돼서 연속 근무가 너무 많아지고"
- "그럼 다시 앞으로 돌아가서..."

사람은 이걸 "직관"과 "시행착오"로 풉니다. 머릿속에서 규칙들을 떠올리고, 하나씩 배치하고, 막히면 되돌아가고...

하지만 컴퓨터는 다릅니다. 컴퓨터는 "모든 가능한 조합"을 빠르게 탐색할 수 있습니다. 단, 한 가지만 필요합니다: 규칙을 명확하게 정의해주는 것.

### 핵심: 규칙을 두 종류로 분류하기

Y씨가 직접 Claude와 대화하면서 문제를 풀어보니, 패턴이 보였습니다.

> 규칙 중에 절대 지켜야 하는 것과, 되도록 지키면 좋은 것이 구분된다.

모든 규칙이 똑같이 중요한 게 아닙니다:

[반드시 지켜야 하는 규칙 (Hard Constraint)]
- 매일 D/E/N 각 10명 배치 (병동 운영 필수)
- 밤 근무 다음날 낮/저녁 금지 (건강 문제)
- 특정 간호사 밤 근무 금지 (개인 사정)
- 연속 근무 6일 제한, 최소 휴무일 보장

[가능하면 좋은 규칙 (Soft Constraint)]
- 근무일수 공평하게
- 휴무일 골고루 분산
- 개인 요청사항 최대한 반영
- 연속 근무 최소화

처음에는 Claude에게 엑셀 파일을 주고 직접 번표를 짜보라고 했습니다. Claude는 사람처럼 한 칸씩 채우고, 규칙에 걸리면 지우고, 다시 채우고... 를 반복했습니다. 되긴 되는데, 느리고 비효율적이었습니다.
생각해보니 어차피 각 칸에 들어갈 수 있는 값은 D, E, N, OFF 네 가지뿐입니다. 그럼 이걸 0, 1, 2, 3이라는 숫자로 바꾸면, 엑셀이 아니라 숫자 행렬이 됩니다. 숫자 행렬이 되면 컴퓨터가 훨씬 빠르게 계산할 수 있습니다.
여기까지 오니 수능 때 풀던 수학 문제가 떠올랐습니다. "조건을 만족하면서 최댓값을 구하라"는 유형. Hard Constraint는 반드시 만족해야 하는 조건이고, Soft Constraint는 점수를 매겨서 높을수록 좋은 것. 이걸 합치면:

> Hard Constraint를 모두 만족하면서, Soft Constraint 점수의 합이 최대가 되는 조합을 찾아라.

전형적인 최적화 문제입니다. 그리고 최적화 문제는 컴퓨터가 사람보다 훨씬 잘 푸는 영역입니다.

---

## 시스템 내부 들여다보기

### 다이어그램 ② - 내부 구조

블랙박스를 열어보면 이런 구조입니다:

![다이어그램 ② - 내부 구조](/pages-book-agent101/assets/41-diagram-2-internal.svg)

Encoder (전처리): 사람이 쓰는 Excel 파일을 컴퓨터가 계산할 수 있는 숫자 행렬로 변환합니다.

최적화 엔진 (핵심 로직): Hard 규칙을 100% 만족하면서 Soft 규칙 점수를 최대화하는 조합을 찾습니다. 수학적으로는 "정수 선형 계획법"이라는 방법을 쓴다고 하는데 이게 뭔지는 모릅니다.

Decoder (후처리): 숫자 행렬을 다시 사람이 보기 좋은 Excel 형식으로 변환합니다.

Y씨가 할 일은 Excel 파일을 업로드하고, 결과 Excel을 다운로드하는 것뿐입니다. 중간의 복잡한 계산은 시스템이 합니다.

---

## 3일간의 개발 과정

Y씨는 이과 출신이라 수학적 접근이 가능했습니다. 문제를 "최적화 문제"로 정의할 수 있었고, 이후 Claude Code와 함께 3일에 걸쳐 시스템을 만들었습니다.

1일차: 문제 정의
- 규칙을 Hard/Soft로 분류
- 입력/출력 형식 정의
- 최적화 알고리즘 선택 (PuLP 라이브러리)

2일차: 핵심 로직 구현
- Loader: Excel → 숫자 행렬
- 최적화 엔진: 규칙을 수학적 제약조건으로 변환
- Writer: 숫자 행렬 → Excel

3일차: UI와 배포
- Streamlit으로 웹 UI 구축
- GitHub에 코드 업로드
- Streamlit Cloud로 자동 배포

결과적으로 개발자 1명이, 서버 없이, 무료로 24시간 서비스를 만들었습니다.

---

## 외부 시스템과의 연결

### 다이어그램 ③ - 전체 서비스 구조

시스템이 실제로 서비스되려면 외부 시스템과 연결되어야 합니다:

![다이어그램 ③ - 배포 구조](/pages-book-agent101/assets/41-diagram-3-deploy.svg)

GitHub: 코드 저장소입니다. 코드를 여기 올려두면 버전 관리도 되고, 다른 사람과 공유도 됩니다.

Streamlit: Python으로 웹 UI를 빠르게 만드는 도구입니다. 코드 30줄 정도로 파일 업로드/다운로드 UI가 완성됩니다. 복잡한 프론트엔드 개발 없이도 사용자가 쓸 수 있는 인터페이스를 만들 수 있습니다.

Streamlit Cloud: GitHub에 올린 Streamlit 앱을 자동으로 배포해주는 서비스입니다. 서버 관리 없이 24시간 서비스가 가능합니다. 무료 티어로도 충분히 운영할 수 있습니다.

---

## Before / After

Before

Y씨는 엑셀을 열고, 한 명씩 배치를 시작합니다.
1일, 2일, 3일... 쭉쭉 진행됩니다.
15일쯤에서 막힙니다. 인원이 안 맞습니다.
다시 10일로 돌아가서 다르게 배치합니다.
20일에서 또 막힙니다. 연속 근무가 7일이 됩니다.
다시 처음부터...

오후 내내, 때로는 퇴근 후에도 계속됩니다.

After

Y씨는 파일을 업로드합니다.
시스템이 5분 동안 계산합니다.
결과를 다운로드합니다.
검증 결과를 확인합니다: "82점/100점 - 모든 필수 규칙 만족"

끝입니다.

---

## 검증 가능한 공정성

수동으로 근무표를 짤 때는, Y씨가 "공정하게 짰다"고 말해도 검증할 방법이 없었습니다. 다른 간호사들은 그냥 믿어야 했죠.

하지만 이제는 다릅니다. 시스템이 만든 근무표에는 점수표가 붙어 나옵니다:

```
82점/100점

상세 점수:
- 필수 규칙 만족: 40/40점 (모든 규칙 100% 만족)
- 휴식 품질: 21/25점 (평균 휴무 7.2일)
- 공정성: 18/20점 (근무일수 표준편차 1.2일)
- 균등성: 8/10점 (주별 분산 낮음)
- 기타: 5/5점
```

규칙은 투명하고, 결과는 검증 가능합니다.

---

## 이 사례가 단순한 이유

이 사례는 비교적 단순한 편입니다:

- 입력/출력이 명확: Excel → Excel
- 규칙이 미리 정해져 있음: 변하지 않는 고정 규칙
- 실시간 연동 없음: 외부 API 호출이나 데이터베이스 연결 없음
- 단일 사용자: 한 사람이 업로드하고 다운로드

더 복잡한 시스템을 만들려면 무엇이 필요할까요?

- 외부 서비스 연결 (API, MCP)
- 여러 단계의 워크플로우 (LangGraph)
- 다중 에이전트 협업
- 실시간 데이터 처리

이어지는 챕터에서 이런 구성요소들을 하나씩 살펴보겠습니다. 간호사 번표처럼 단순한 사례로 "시스템 사고"의 기초를 익혔으니, 이제 더 복잡한 세계로 나아갈 준비가 됐습니다.

---

핵심 요약

1. 시스템으로 보기: 입력 2개 → 블랙박스 → 출력 1개
2. 규칙 분류: 반드시 지켜야 하는 것(Hard) vs 가능하면 좋은 것(Soft)
3. 도구 활용: Streamlit(UI) + GitHub + Cloud(배포)
4. 결과: 개발자 1명, 서버 비용 0원, 24시간 서비스

---

작성일: 2026-01-07
Chapter: Part 4, Chapter 4.1
키워드: 시스템 사고, 최적화, 규칙 분류, Streamlit, 서버리스

---
<!-- LLM Context Anchor -->
**핵심 요약**: 간호사 번표 사례로 시스템 사고 학습. 입력(지난달 번표 + 요청사항) → 블랙박스 → 출력(다음달 번표). 규칙을 Hard Constraint(필수)와 Soft Constraint(선호)로 분류하면 최적화 문제가 됨. Encoder→최적화엔진→Decoder 구조. Streamlit+GitHub+Cloud로 개발자 1명, 서버비용 0원, 24시간 서비스.

**키워드**: `시스템사고` `Hard/SoftConstraint` `최적화` `Streamlit` `서버리스`
