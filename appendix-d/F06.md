---
title: "F06. MAS Patterns"
nav_order: 11
parent: 부록 D
---

돋보기를 들고 조직과 스타트업을 본 게 F04였고, 에이전트 하나의 내부를 본 게 F05였습니다. 이번엔 에이전트들이 어떻게 조직화되는지를 봅니다.

멀티 에이전트 서비스를 위해서는 다양한 에이전트와 툴이 연결되는 것이 필요합니다. 그래서 앞서 MCP와 A2A를 배웠습니다. 이제 어떤 '방식'으로 협력하느냐가 중요합니다.

이걸 아키텍처 패턴이라고 부릅니다. 복잡한 기술 용어 대신, 조직에서 일하는 방식으로 비유해 보겠습니다. (다만 Single Agent System에 대비하여 Multi Agent System이 우월한 것이 아닙니다. 반드시 아래의 내용들을 모두 알아야 착수 가능한 것도 아닙니다. 필요한 시점이 올 겁니다. 그 때 참고하세요!)

---

## ReAct: 혼자 일하는 꼼꼼한 담당자

ReAct는 "Reasoning + Acting"의 줄임말입니다. 생각하고, 행동하고, 결과를 확인하고, 다시 생각하는 사이클을 반복합니다.

조직에 비유하면, 혼자서 일을 처리하는 꼼꼼한 담당자입니다.

![ReAct 패턴](/pages-book-agent101/assets/react-pattern.svg)

**예시 흐름:**
1. 요청: "경쟁사 분석해줘"
2. 생각: "먼저 경쟁사 목록이 필요하겠네"
3. 행동: 검색("업계 경쟁사")
4. 관찰: "A사, B사, C사..."
5. 생각: "각 회사 매출 정보도 필요하겠군"
6. 행동: 검색("A사 매출")
7. (충분할 때까지 반복)
8. 답변: "경쟁사 분석 결과입니다..."

이 패턴의 장점은 단순하고 예측 가능하다는 것입니다. 한 사람이 차근차근 일을 처리하니까요. 단점은 복잡한 일에는 느리고, 그 한 사람의 능력에 한계가 있다는 것입니다.

---

## Orchestrator-Worker: 팀장과 실무자

일이 커지면 혼자 감당이 안 됩니다. 그래서 역할을 나눕니다.

Orchestrator-Worker 패턴은 말 그대로 오케스트라 지휘자와 연주자의 관계입니다. 조직으로 치면 팀장과 팀원이죠.

![Orchestrator-Worker 패턴](/pages-book-agent101/assets/orchestrator-worker.svg)

**Orchestrator(팀장)의 역할:**
- 전체 작업을 파악하고 계획을 세웁니다
- 작업을 적절한 단위로 나눕니다
- 각 작업을 적합한 Worker에게 배분합니다
- 결과물을 모아서 종합합니다

**Worker(팀원)의 역할:**
- 자신에게 주어진 작업을 수행합니다
- 결과를 Orchestrator에게 보고합니다

이 패턴의 장점은 복잡한 작업을 병렬로 처리할 수 있다는 것입니다. 세 명이 동시에 일하면 세 배 빨라지죠(이상적으로는). 단점은 조율 비용이 든다는 것입니다. 팀장이 일을 잘못 나누면 오히려 혼란이 생깁니다.

---

## Router: 안내 데스크

때로는 작업 자체를 수행하는 게 아니라, 적절한 곳으로 '연결'해주는 역할이 필요합니다.

Router는 고객센터의 안내 데스크와 같습니다. 전화가 오면 "무슨 용건이신가요?"를 파악하고, 적절한 부서로 연결해줍니다.

![Router 패턴](/pages-book-agent101/assets/router-pattern.svg)

Router가 똑똑할수록 사용자는 빠르게 원하는 답을 얻습니다. Router가 멍청하면 사용자는 여러 부서를 떠돌게 되죠. 우리 모두 경험해봤을 겁니다, 고객센터에서 "담당 부서로 연결해드리겠습니다"를 세 번 듣는 그 좌절감을.

---

## Evaluator-Optimizer: 편집자와 검토 루프

글을 쓰는 사람과 글을 검토하는 사람이 다르면 품질이 올라갑니다. 자기가 쓴 글의 오류는 자기 눈에 잘 안 보이니까요.

Evaluator-Optimizer 패턴은 바로 이 원리를 적용합니다.

![Evaluator-Optimizer 패턴](/pages-book-agent101/assets/evaluator-optimizer.svg)

**작동 방식:**
1. 생성자가 결과물을 만듭니다
2. 평가자가 결과물을 검토하고 피드백을 줍니다
3. 생성자가 피드백을 반영해서 개선합니다
4. 2-3을 품질이 충분할 때까지 반복합니다

이 패턴의 장점은 품질이 점진적으로 개선된다는 것입니다. 단점은 시간이 오래 걸린다는 것이죠. 반복 횟수를 어디서 끊을지도 판단이 필요합니다. 완벽을 추구하다 영원히 끝나지 않을 수도 있으니까요.

---

## 자율 멀티에이전트: 대표 없이 돌아가는 조직

이제 가장 복잡한 패턴입니다. 여러 에이전트가 각자의 역할을 가지고, 서로 소통하며, 큰 목표를 향해 협력하는 구조입니다.

이건 마치 대표 없이 돌아가는 조직, 또는 역할이 명확히 분담된 스타트업 팀과 비슷합니다.

![자율 멀티에이전트 패턴](/pages-book-agent101/assets/multi-agent-autonomous.svg)

각자가 자기 일을 하면서, 필요할 때 서로 정보를 주고받습니다. 누가 시키지 않아도 자기 역할에 맞는 일을 찾아서 합니다.

이 구조가 제대로 작동하려면 몇 가지 조건이 필요합니다:

**명확한 역할 정의**: 누가 뭘 담당하는지 모호하면 일이 중복되거나 빠집니다.

**효과적인 소통 방식**: 서로 어떻게 정보를 주고받을지 정해져야 합니다. 앞 챕터에서 다룬 A2A 프로토콜이 바로 이 역할을 합니다.

**공유된 목표**: 각자 자기 일만 하면 전체가 산으로 갑니다. 모두가 같은 방향을 보고 있어야 합니다.

---

## 생각을 연결하는 기술: Prompt Chaining

ReAct가 "생각하고 행동하고 확인하는" 사이클이라면, Prompt Chaining은 조금 다른 접근입니다. 행동 없이, 생각만 단계별로 연결하는 방식이죠.

복잡한 문제를 풀 때 우리는 어떻게 하나요? 한 번에 답을 내려고 하면 머리가 터집니다. 대신 단계별로 접근합니다.

![Prompt Chaining 패턴](/pages-book-agent101/assets/prompt-chaining.svg)

각 단계는 단순합니다. 하지만 이걸 순서대로 연결하면 복잡한 문제도 풀 수 있습니다.

왜 이게 효과적일까요?

**실수가 줄어듭니다.** "이 문서를 요약하고, 핵심 논점을 뽑고, 반론을 만들고, 최종 결론을 내려줘"라고 한 번에 시키면 중간에 뭔가 빠지거나 엉킬 확률이 높습니다. 단계별로 나누면 각 단계를 확인할 수 있습니다.

**중간 결과를 검토할 수 있습니다.** 요약이 잘못됐으면 거기서 고치면 됩니다. 한 번에 끝까지 가버리면 어디서 틀어졌는지 찾기 어렵습니다.

**재사용이 가능합니다.** "요약하기" 단계는 다른 작업에도 쓸 수 있습니다. 레고 블록처럼 조합할 수 있는 거죠.

---

## 여러 의견을 모으는 방법: MoA

MoA(Mixture of Agents)는 여러 전문가에게 자문을 구하는 것과 같습니다.

![MoA 패턴](/pages-book-agent101/assets/moa-pattern.svg)

LLM은 확률적입니다. 같은 질문에도 매번 조금씩 다른 답을 합니다. 이 '다름'이 때로는 문제지만, 때로는 장점입니다.

한 번의 답변에서 놓친 관점을 다른 답변이 잡아낼 수 있습니다. 한 답변의 오류를 다른 답변과 비교해서 발견할 수 있습니다. 여러 답변에서 공통으로 나오는 내용은 신뢰도가 높다고 볼 수 있습니다.

물론 비용이 듭니다. 한 번 물어볼 걸 세 번 물어보니까요. 그래서 모든 상황에 쓰는 건 아니고, 중요한 결정이나 품질이 critical한 경우에 선택적으로 사용합니다.

---

## 코드로 문제를 푸는 에이전트: CodeAct

에이전트가 문제를 푸는 방식 중 흥미로운 접근이 "코드를 짜서 실행하는" 방식입니다.

![CodeAct 비교](/pages-book-agent101/assets/codeact-comparison.svg)

코드는 거짓말을 하지 않습니다. 계산기가 2+2를 5라고 하지 않듯이, 올바른 코드는 올바른 답을 냅니다.

이 방식의 장점:
- 복잡한 계산도 정확하게 처리
- 대량의 데이터도 빠르게 처리
- 과정이 투명함 (코드를 보면 뭘 했는지 알 수 있음)

CodeAct는 특히 데이터 분석, 수학적 계산, 반복 작업에 강합니다. 반면 창의적 글쓰기나 감성적 판단이 필요한 일에는 별로 맞지 않죠.

---

## 동시에 일하기: Parallelization

순서대로 일하는 것과 동시에 일하는 것. 어느 쪽이 빠를까요?

![병렬 처리 비교](/pages-book-agent101/assets/parallelization.svg)

하지만 아무 작업이나 병렬로 할 수 있는 건 아닙니다.

**독립적이어야 합니다.** A 작업의 결과가 있어야 B 작업을 시작할 수 있다면, 병렬로 할 수 없습니다.

**합칠 수 있어야 합니다.** 병렬로 처리한 결과들을 나중에 종합할 방법이 있어야 합니다.

병렬화의 함정도 있습니다. 일을 나누고 결과를 합치는 것 자체가 시간이 듭니다. 작업이 너무 작으면 오히려 순차 처리가 빠를 수 있습니다.

---

## 사람이 끼어드는 지점: Human-in-the-loop

완전 자율 에이전트는 아직 위험합니다. 에이전트가 실수할 수 있고, 잘못된 판단을 할 수 있고, 의도치 않은 결과를 낼 수 있습니다.

Human-in-the-loop는 이 문제에 대한 현실적인 답입니다. 완전 자동화 대신, 중요한 지점에서 사람이 확인하고 승인하는 구조입니다.

![Human-in-the-loop 패턴](/pages-book-agent101/assets/human-in-the-loop.svg)

어디에 사람을 넣을까요?

**계획 승인**: 에이전트가 "이렇게 하겠습니다"라고 계획을 제시하면, 사람이 "좋아, 진행해"라고 승인합니다.

**중간 검토**: 에이전트가 어느 정도 진행한 후, 중간 결과를 사람에게 보여주고 피드백을 받습니다.

**최종 확인**: 에이전트가 일을 끝낸 후, 실제로 실행하기 전에 사람이 최종 확인합니다.

이건 신입 직원을 관리하는 것과 비슷합니다. 처음엔 모든 일을 검토합니다. 신뢰가 쌓이면 점점 자율권을 늘려갑니다. 하지만 중요한 결정은 여전히 확인합니다.

---

## 실제 서비스는 어떻게 만들어졌나

### DeepResearch: 연구 보조원

DeepResearch 류의 서비스는 "깊이 있는 조사"를 자동화합니다. 사용자가 주제를 주면, 알아서 조사하고 보고서를 작성해줍니다.

![DeepResearch 구조](/pages-book-agent101/assets/deep-research.svg)

구조를 뜯어보면:

**Orchestrator (연구 책임자)**: 전체 연구 계획을 세우고, 어떤 하위 조사가 필요한지 결정하고, 각 조사를 Sub-agent에게 배분하고, 결과를 종합해서 최종 보고서를 구성합니다.

**Researcher Sub-agents (연구 보조원들)**: 각자 맡은 주제를 조사하고, 웹 검색/문서 조회를 수행하고, 조사 결과를 정리해서 Orchestrator에게 보고합니다.

**Writer Sub-agent (작성 담당)**: 조사 결과를 받아서 글로 작성하고, 일관된 톤과 구조를 유지하고, 인용과 출처를 정리합니다.

이게 Orchestrator-Worker 패턴의 전형적인 예입니다. 여기에 Agentic RAG(자율적 검색), Human-in-the-loop(중간 계획 승인), Prompt Chaining(단계별 작성), Evaluator-Optimizer(품질 검토) 등이 결합됩니다.

---

## 정리

멀티에이전트 시스템을 설계할 때, 이런 패턴들을 조합해서 사용합니다.

| 패턴 | 비유 | 적합한 상황 |
|-----|-----|-----------|
| ReAct | 혼자 일하는 담당자 | 단순하고 순차적인 작업 |
| Orchestrator-Worker | 팀장과 팀원 | 복잡한 작업의 분할 |
| Router | 안내 데스크 | 작업 유형에 따른 분기 |
| Evaluator-Optimizer | 편집자와 검토 | 품질이 중요한 결과물 |
| MoA | 여러 전문가 자문 | 신뢰도가 중요한 결정 |
| CodeAct | 계산기 사용 | 정확한 계산이 필요한 작업 |
| Parallelization | 동시 작업 | 독립적인 작업의 병렬 처리 |
| Human-in-the-loop | 신입 관리 | 위험도가 높은 작업 |

실제 서비스는 이 패턴들을 여러 개 조합해서 만들어집니다. DeepResearch는 Orchestrator-Worker + Evaluator-Optimizer + Agentic RAG를 조합했고, Claude Code 같은 도구는 ReAct + CodeAct + Human-in-the-loop를 조합했습니다.

중요한 건 각 패턴의 장단점을 이해하고, 상황에 맞게 선택하는 것입니다.

---

*Framework 06 of 6: MAS Patterns*
