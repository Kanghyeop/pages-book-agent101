---
title: "D05. F02. SW Ecosystem"
nav_order: 5
parent: 부록 D
---

> 컴퓨터 구조부터 시작해서 소프트웨어가 돌아가는 4개 계층을 이해하는 프레임워크

---

## 요약

| # | 계층 | 실행 위치 | 주요 언어 | 배포 방식 | 예시 |
| --- | --- | --- | --- | --- | --- |
| 0 | HW | - | - | - | CPU, 모니터, 키보드 |
| 1 | OS | 하드웨어 위 | C, C++, Rust | 설치 | Windows, macOS, Linux |
| 2 | 로컬 | OS 위 | Python, C#, Electron | 다운로드 | VS Code, Excel, Claude Code |
| 3 | 웹 | 브라우저 | HTML/JS, Python/Node | 서버 배포 | Gmail, Notion, ChatGPT |
| 4 | 앱 | 모바일 OS | Swift, Kotlin, Flutter | 스토어 심사 | 카카오톡, 인스타그램 |

---

## 0. 컴퓨터의 기본 구조

소프트웨어를 이해하려면 먼저 하드웨어를 알아야 합니다. 컴퓨터는 결국 입력 → 처리 → 출력의 기계입니다.

입력장치는 사람의 명령을 컴퓨터가 이해할 수 있는 신호로 바꿉니다.

- 키보드: 텍스트 입력
- 마우스: 위치와 클릭
- 마이크: 소리를 디지털 신호로
- 카메라: 영상을 디지털 데이터로

처리장치는 입력된 데이터를 계산하고 처리합니다.

- CPU (Central Processing Unit): 모든 계산을 수행하는 두뇌
- 메모리 (RAM): 현재 작업 중인 데이터를 임시 저장
- GPU: 그래픽 처리, 요즘은 AI 연산에도 사용

출력장치는 처리 결과를 사람이 인식할 수 있게 보여줍니다.

- 모니터: 시각적 출력
- 스피커: 소리 출력
- 프린터: 물리적 출력

저장장치는 전원이 꺼져도 데이터를 보관합니다.

- SSD/HDD: 파일, 프로그램, 운영체제 저장
- USB, 외장하드: 이동식 저장

이 모든 하드웨어가 있어도, 그것만으로는 아무것도 못 합니다. 하드웨어를 제어하고 프로그램을 실행할 소프트웨어가 필요합니다. 그 첫 번째가 운영체제입니다.

---

## 1. OS (운영체제)

운영체제(Operating System)는 하드웨어와 프로그램 사이의 중재자입니다.

프로그램이 "이 파일을 저장해"라고 요청하면, OS가 하드디스크와 대화해서 실제로 저장합니다. 프로그램이 "화면에 이걸 그려줘"라고 하면, OS가 GPU와 모니터에 명령을 전달합니다. 프로그램 개발자는 하드웨어의 복잡한 세부사항을 몰라도 됩니다. OS가 대신 처리해주니까요.

OS가 하는 일:

- 파일 시스템 관리 (폴더, 파일 읽기/쓰기)
- 메모리 관리 (어떤 프로그램에 얼마나 할당할지)
- 프로세스 관리 (여러 프로그램을 동시에 실행)
- 하드웨어 드라이버 관리 (프린터, 마우스 등 연결)

데스크톱 OS:

- Windows: 전 세계 PC의 70% 이상. 게임, 사무용
- macOS: Apple 컴퓨터 전용. 디자인, 개발자 선호
- Linux: 오픈소스. 서버의 90% 이상이 Linux

모바일 OS:

- Android: 스마트폰의 70%. Google이 만든 Linux 기반
- iOS: iPhone, iPad 전용. Apple 생태계

OS를 만드는 데는 C, C++, Rust 같은 언어가 쓰입니다. 하드웨어에 가깝게 접근해야 하고, 속도와 안정성이 중요하기 때문이죠.

일반 사용자가 OS를 직접 만들 일은 없습니다. 하지만 OS가 무엇인지 알면, "왜 이 프로그램은 Mac에서 안 돌아가지?", "왜 iPhone 앱과 Android 앱을 따로 만들어야 하지?"라는 질문에 답할 수 있습니다.

---

## 2. 로컬 프로그램

로컬 프로그램은 내 컴퓨터에 설치해서 쓰는 소프트웨어입니다.

OS 위에서 돌아갑니다. 설치 파일을 다운로드해서 실행하면 내 컴퓨터에 깔립니다. 인터넷이 없어도 실행할 수 있습니다. 내 컴퓨터의 파일에 직접 접근할 수 있죠.

예시:

- Microsoft Office (Word, Excel, PowerPoint): 문서 작업
- VS Code: 코드 편집기
- Photoshop: 이미지 편집
- Claude Code: AI 코딩 에이전트 (터미널에서 실행)

사용되는 언어:

- Python: 데이터 분석, 자동화, AI 도구
- C#: Windows 앱 개발에 강함
- Java: 어디서든 돌아가도록 설계됨
- Electron (JavaScript): VS Code, Slack, Discord가 이걸로 만들어짐

배포 방식:

```
개발자 → 코드 작성 → 빌드(컴파일) → 설치파일 생성 → 웹사이트/GitHub 업로드 → 사용자 다운로드 → 설치
```

장점: 오프라인 사용, 빠른 속도, 내 컴퓨터 파일 직접 접근
단점: 설치 필요, 업데이트 시 재설치, OS별로 따로 빌드

Claude Code가 로컬 프로그램인 이유가 있습니다. 터미널에서 돌면서 내 프로젝트 폴더의 파일을 직접 읽고, 수정하고, git 명령을 실행합니다. 브라우저 안에서는 이런 권한이 없습니다.

---

## 3. 웹서비스

웹서비스는 브라우저를 통해 접속해서 쓰는 서비스입니다.

설치가 필요 없습니다. URL을 입력하면 바로 쓸 수 있습니다. 내 컴퓨터가 아닌 서버에서 돌아갑니다. 인터넷이 있어야 쓸 수 있죠.

예시:

- Gmail: 이메일
- Google Docs: 문서 작업 (클라우드 저장)
- Notion: 노트, 위키, 프로젝트 관리
- ChatGPT 웹버전: AI 대화

구조 (두 부분으로 나뉩니다):

프론트엔드 (사용자가 보는 화면):

- HTML: 페이지의 구조
- CSS: 디자인, 레이아웃
- JavaScript: 동적 동작 (버튼 클릭 시 반응)
- React, Vue, Next.js 같은 프레임워크가 이를 쉽게 만들어줌

백엔드 (서버에서 돌아가는 로직):

- Python (Flask, FastAPI, Django)
- Node.js (JavaScript를 서버에서 실행)
- 데이터베이스 연결, API 처리, 인증

배포 방식:

```
개발자 → 코드 작성 → GitHub 푸시 → Vercel/Streamlit 자동 배포 → 서버에서 실행 → 사용자 브라우저 접속
```

요즘은 Vercel, Netlify, Streamlit 덕분에 서버 관리 없이 쉽게 배포할 수 있습니다. 코드를 GitHub에 올리면 몇 분 내에 배포됩니다.

장점: 설치 불필요, 어디서든 접근, 업데이트 즉시 반영
단점: 인터넷 필수, 서버 속도 의존, 오프라인 불가

ChatGPT가 웹서비스인 이유는 뭘까요? 브라우저에서 접속하고, 대화 내용은 OpenAI 서버에 저장됩니다. 내 컴퓨터 파일에 직접 접근할 수 없습니다. (Code Interpreter 같은 기능은 OpenAI 서버의 샌드박스에서 실행됩니다)

---

## 4. 앱서비스

앱서비스는 스마트폰이나 태블릿에서 돌아가는 애플리케이션입니다.

로컬 프로그램과 비슷해 보입니다. 다운로드해서 설치하고, 기기에서 실행됩니다. 하지만 결정적인 차이가 있습니다: 앱스토어 심사. Apple App Store나 Google Play Store에 앱을 올리려면 심사를 통과해야 합니다.

예시:

- 카카오톡: 메신저
- 인스타그램: 소셜 미디어
- 배달의민족: 음식 주문
- 토스: 금융

사용되는 언어:

- Swift: iOS 전용 (Apple 공식)
- Kotlin: Android 전용 (Google 권장)
- Flutter (Dart): 크로스플랫폼 - 한 번 작성, iOS/Android 둘 다 지원
- React Native (JavaScript): 크로스플랫폼

iOS와 Android 앱을 따로 만들면 비용이 두 배입니다. 그래서 Flutter나 React Native 같은 크로스플랫폼 도구가 인기입니다.

배포 방식:

```
개발자 → 코드 작성 → 빌드 → 스토어 제출 → 심사 (1~14일) → 승인 → 스토어 등록 → 사용자 다운로드
```

장점: 푸시 알림, 카메라/GPS/센서 접근, 오프라인 기능 일부 지원
단점: 스토어 심사 필요, 업데이트 지연, iOS/Android 각각 대응

---

## 5. 정리: 개발자에서 사용자까지

| 계층 | 배포 경로 | 소요 시간 | 업데이트 |
| --- | --- | --- | --- |
| 로컬 | 빌드 → 업로드 → 다운로드 → 설치 | 분~시간 | 사용자가 재설치 |
| 웹 | GitHub → 자동배포 → 브라우저 | 분 | 즉시 반영 |
| 앱 | 빌드 → 스토어 심사 → 설치 | 일~주 | 사용자가 업데이트 |

웹이 가장 빠릅니다. 코드 수정하고 푸시하면 몇 분 내에 모든 사용자에게 반영됩니다.
앱이 가장 느립니다. 심사 기간이 있고, 사용자도 업데이트 버튼을 눌러야 하죠.

---

## 마무리: 에이전트는 어디서 돌아가나?

AI 에이전트를 이해하려면 이 질문이 중요합니다: 어떤 계층에서 실행되는가?

| 에이전트 | 계층 | 특징 |
| --- | --- | --- |
| Claude Code | 로컬 | 내 파일 직접 접근, git 명령 실행 |
| ChatGPT | 웹 | 브라우저에서 접속, 서버에서 실행 |
| Siri, Google Assistant | 앱+OS | 시스템 기능 접근 (알람, 전화 등) |

로컬 에이전트는 강력합니다. 내 컴퓨터의 파일을 읽고 쓸 수 있습니다. 하지만 설치가 필요하죠.
웹 에이전트는 편리합니다. 어디서든 접속할 수 있습니다. 하지만 브라우저 밖으로 나갈 수 없습니다.
앱 에이전트는 항상 곁에 있습니다. 푸시 알림으로 먼저 말을 걸 수 있습니다. 하지만 스토어 심사를 받아야 합니다.

소프트웨어가 어디서 돌아가는지 알면, 도구의 가능성과 한계를 파악할 수 있습니다.
