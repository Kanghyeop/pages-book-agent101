---
title: "보안 주의사항"
nav_order: 5
parent: 부록 A
---


## 주장

비개발자들이 AI 도구로 개발할 때 보안 사고가 발생하기 쉽다. 편리함과 속도에 취해 기본적인 보안 원칙을 간과하면 큰 사고로 이어질 수 있다.

## 비개발자가 흔히 저지르는 보안 실수

### 1. API Key를 GitHub에 배포하기

시나리오:
- Claude Code로 빠르게 개발
- 작동하는 코드를 Git에 커밋
- API Key가 그대로 코드에 포함됨
- Public repository에 push
- 몇 시간 내로 봇이 스캔해서 Key 탈취
- 다음날 수백만원 청구서 도착

실제 사례:
```python
# 절대 이렇게 하지 마세요!
OPENAI_API_KEY = "sk-proj-xxxxxxxxxxxxx"
DATABASE_PASSWORD = "mypassword123"
AWS_SECRET_KEY = "AKIAIOSFODNN7EXAMPLE"
```

올바른 방법:
```python
# .env 파일 사용 (Git에 포함하지 않음)
import os
from dotenv import load_dotenv

load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
```

예방책:
- `.gitignore`에 `.env` 파일 추가
- 환경변수 사용
- Git commit 전에 항상 Key 포함 여부 확인
- GitHub Secret 기능 활용
- Pre-commit hook으로 Key 스캔

### 2. 인증 안 된 MCP 막 써서 해킹당하기

시나리오:
- 인터넷에서 "편리한 MCP 서버" 발견
- 검증 없이 설치
- 해당 MCP가 악성 코드 포함
- 로컬 파일 접근 권한 획득
- 민감한 정보 유출

위험한 행동:
- 출처 불명의 MCP 서버 설치
- GitHub star 수가 적은 프로젝트 무분별 사용
- 코드 리뷰 없이 실행
- 과도한 권한 부여

안전한 사용법:
- 공식 문서에 나온 MCP만 사용
- GitHub repository 신뢰도 확인 (star, contributor, 최근 업데이트)
- 가능하면 코드 리뷰
- 최소 권한 원칙 적용
- 샌드박스 환경에서 먼저 테스트

### 3. 서버/토큰 비용 폭탄 맞기

시나리오:
- 무한 루프 에이전트 실행
- Rate limit 없이 API 호출
- 프로덕션에서 Opus 모델 무제한 사용
- 다음달 청구서: $50,000

실제 사례:
```python
# 위험한 코드
while True:
    response = client.chat.completions.create(
        model="claude-opus-4",  # 가장 비싼 모델
        messages=[{"role": "user", "content": user_input}]
    )
    # 무한 반복...
```

예방책:
- 예산 알림 설정: OpenAI/Anthropic 콘솔에서 예산 한도 설정
- Rate limiting: API 호출 빈도 제한
- 모델 선택: 테스트는 Haiku/Sonnet, 프로덕션만 필요시 Opus
- 로깅과 모니터링: 토큰 사용량 실시간 추적
- 캐싱: 반복 호출 최소화

실용적 가이드:
- 개발 단계: Haiku (저렴)
- 테스트 단계: Sonnet (중간)
- 프로덕션: 필요시만 Opus
- 월 예산 한도 설정 ($100, $500 등)
- 알림 임계값 설정 (80% 도달 시 알림)

### 4. 업무 프로세스 정리 후 권한 관리 실패

시나리오: goldenRabbit 출판사 사례

출판사 goldenRabbit이 AI 에이전트 시스템을 구축했다고 가정해보자.

1단계: 업무 프로세스 완벽 정리
- GitHub에 `goldenRabbit` 레포지토리 생성
- 모든 업무 프로세스를 상세히 문서화
  - 기획 → 번역 → 교정교열 → 마케팅 전 과정
  - 에이전트 설정 파일
  - 프롬프트 템플릿
  - 자동화 워크플로우
  - 노하우와 판단 기준
- 깔끔하게 정리된 README와 Wiki
- 실행 가능한 스크립트까지 포함

2단계: 권한 관리 실패
- "팀원들 협업 편하게" → Full 권한 부여
- 모든 직원이 전체 레포지토리 접근 가능
- 다운로드 제한 없음

3단계: 정보 유출
- 퇴사 예정 직원 A가 전체 레포지토리 다운로드
- 경쟁사 B 출판사에 이직
- "저희 이런 시스템 있습니다!" 하며 공유
- goldenRabbit의 핵심 노하우가 경쟁사로 유출
- 수년간 쌓은 경쟁력이 한순간에 무너짐

역설적 상황:
> 정리를 잘하면 보안에 오히려 위험해진다!

업무가 엑셀과 메모장에 흩어져 있을 때는 아무도 가져갈 엄두를 못 낸다. 하지만 깔끔하게 정리되고 자동화된 순간, 복사 한 번으로 모든 것이 유출될 수 있다.

올바른 권한 관리:

```
역할별 권한 분리:

1. 관리자 (CTO, PM)
   - Full access
   - 레포지토리 설정 변경
   - 권한 관리

2. 개발자
   - Read + Write (특정 브랜치)
   - 코드 수정 가능
   - 전체 다운로드 제한

3. 일반 직원
   - Read only (필요한 문서만)
   - 실행만 가능 (코드 접근 불가)
   - 다운로드 제한

4. 임시직/인턴
   - 최소 권한
   - 특정 파일만 접근
   - 로그 기록
```

기술적 보안 조치:
- Branch protection rules
- Required reviews for merge
- IP 제한 (사무실에서만 접근)
- 2FA (이중 인증) 필수
- 접근 로그 모니터링
- 퇴사자 즉시 권한 박탈

조직적 보안 조치:
- 보안 서약서
- 퇴사 시 지적재산권 확인
- 정기적 권한 감사
- 민감 정보 분리 저장

## 보안 체크리스트

### 개발 시

- [ ] API Key를 코드에 직접 넣지 않았는가?
- [ ] `.env` 파일이 `.gitignore`에 포함되어 있는가?
- [ ] 비밀번호가 하드코딩되어 있지 않은가?
- [ ] Git commit 전에 민감 정보를 확인했는가?

### MCP/도구 사용 시

- [ ] 출처가 명확한 도구만 사용하는가?
- [ ] 설치 전에 GitHub star/contributor를 확인했는가?
- [ ] 과도한 권한을 요청하지 않는가?
- [ ] 샌드박스에서 먼저 테스트했는가?

### 비용 관리

- [ ] API 예산 한도를 설정했는가?
- [ ] 알림 임계값을 설정했는가?
- [ ] 무한 루프 방지 로직이 있는가?
- [ ] 토큰 사용량을 모니터링하는가?

### 권한 관리

- [ ] 역할별로 권한이 분리되어 있는가?
- [ ] 최소 권한 원칙을 적용했는가?
- [ ] 접근 로그를 기록하는가?
- [ ] 퇴사자 권한을 즉시 회수하는가?

## 결론

보안은 "나중에"가 아니라 "처음부터" 고려해야 한다.

편리함과 속도는 중요하지만, 보안 사고 한 번이면 모든 노력이 물거품이 된다.

핵심 원칙:
1. 의심하라: 편리한 것일수록 의심하라
2. 최소 권한: 꼭 필요한 권한만 부여하라
3. 모니터링: 항상 사용량과 접근을 추적하라
4. 분리하라: 민감 정보는 별도로 관리하라

---

작성일: 2026-01-06
Chapter: Part 6, Chapter 2 - Security
키워드: 보안, API Key, MCP, 비용 폭탄, 권한 관리
상태: 미분류 (93)

---
<!-- LLM Context Anchor -->
**핵심 요약**: 비개발자 흔한 보안 실수 4가지. ①API Key를 GitHub에 배포(환경변수 사용, .gitignore). ②인증 안 된 MCP 사용(공식만, 최소권한). ③서버/토큰 비용 폭탄(예산한도, Rate limiting). ④권한 관리 실패(역할별 분리, 퇴사자 즉시 회수). 역설: 정리를 잘하면 보안에 오히려 위험. 핵심 원칙: 의심, 최소권한, 모니터링, 분리.

**키워드**: `보안` `APIKey` `비용폭탄` `권한관리` `최소권한원칙`
